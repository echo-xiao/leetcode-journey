【复习：#979 增减字符串匹配】
难度：Easy | 归类：1. 滑动窗口与双指针
═══════════════

979. 增减字符串匹配

难度: Easy | 标签: Array Two Pointers String Greedy

 题目描述

由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:

	如果 perm[i] < perm[i + 1] ，那么 s[i] == 'I' 
	如果 perm[i] > perm[i + 1] ，那么 s[i] == 'D' 

给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。

 

示例 1：

输入：s = "IDID"
输出：[0,4,1,3,2]

示例 2：

输入：s = "III"
输出：[0,1,2,3]

示例 3：

输入：s = "DDI"
输出：[3,2,0,1]

 

提示：

	1 <= s.length <= 105
	s 只包含字符 "I" 或 "D"

---
 解题思路与复盘

1. 一句话直击本质：算法的核心逻辑是通过双指针法，根据字符串中的'I'和'D'分别从数组的两端选择合适的数字填入结果数组。

2. 综合思路：
   - 双指针法：所有版本都采用了双指针法，使用两个指针分别指向当前可用的最小值和最大值，根据字符串中的字符选择合适的值填入结果数组。
   - 版本 1 和 3：直接使用两个变量 left 和 right 来表示当前可用的最小值和最大值。
   - 版本 2：使用一个预先生成的列表 lst 来存储所有可能的数字，然后通过索引访问。

3. 全量伪代码：
   - 初始化一个空数组 arr 用于存储结果。
   - 初始化两个指针 left 和 right，分别指向 0 和字符串长度。
   - 对于字符串中的每个字符：
     - 如果字符是 'I'，将 left 指针指向的值加入 arr，然后将 left 增加 1。
     - 如果字符是 'D'，将 right 指针指向的值加入 arr，然后将 right 减少 1。
   - 将 left 指针指向的值加入 arr（此时 left 和 right 应该相等）。
   - 返回结果数组 arr。

4. 复杂度：
   - 时间复杂度：O(n)，其中 n 是字符串的长度，因为我们需要遍历字符串一次。
   - 空间复杂度：O(n)，因为结果数组 arr 的长度与字符串长度相同。