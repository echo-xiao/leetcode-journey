# 1168. 复写零

**难度**: Easy | **标签**: `Array` `Two Pointers`

## 题目描述

<p>给你一个长度固定的整数数组&nbsp;<code>arr</code> ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。</p>

<p>注意：请不要在超过该数组长度的位置写入元素。请对输入的数组&nbsp;<strong>就地&nbsp;</strong>进行上述修改，不要从函数返回任何东西。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>arr = [1,0,2,3,0,4,5,0]
<strong>输出：</strong>[1,0,0,2,3,0,0,4]
<strong>解释：</strong>调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>arr = [1,2,3]
<strong>输出：</strong>[1,2,3]
<strong>解释：</strong>调用函数后，输入的数组将被修改为：[1,2,3]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt;= 9</code></li>
</ul>


---
## 解题思路与复盘

1. **一句话直击本质：** 通过遍历数组并在遇到零时插入额外的零，同时保持数组长度不变。

2. **综合思路：**
   - **版本 1：** 计算需要的插槽数量，确定从后向前复制元素的位置，避免直接插入和删除操作。
   - **版本 2 和 3：** 直接在数组中插入零并移除最后一个元素以保持数组长度不变，区别在于版本 2 每次遇到零时插入，而版本 3 通过条件判断来决定插入和跳过。

3. **全量伪代码：**

   - **版本 1 伪代码：**
     ```
     初始化 slot 为 0
     计算数组长度 n
     遍历数组：
       如果当前元素是 0，slot 增加 2
       否则，slot 增加 1
       如果 slot 大于等于 n，跳出循环
     初始化 j 为 n - 1
     如果 slot 大于 n 且当前元素是 0：
       将 arr[j] 设为 0
       j 和 i 各自减 1
     从 i 开始向前遍历：
       如果当前元素是 0：
         将 arr[j] 设为 0，j 减 1
         将 arr[j] 设为 0，j 减 1
       否则：
         将 arr[j] 设为 arr[i]，j 减 1
       i 减 1
     返回 arr
     ```

   - **版本 2 和 3 伪代码：**
     ```
     初始化 i 为 0
     当 i 小于数组长度时：
       如果当前元素是 0：
         删除数组最后一个元素
         在 i+1 位置插入 0
         i 增加 1
       i 增加 1
     ```

4. **复杂度：**

   - **版本 1 时间复杂度：** $O(n)$，因为每个元素最多处理两次。
   - **版本 1 空间复杂度：** $O(1)$，因为只使用了常数额外空间。

   - **版本 2 和 3 时间复杂度：** $O(n^2)$，因为插入和删除操作在数组中是线性时间复杂度。
   - **版本 2 和 3 空间复杂度：** $O(1)$，因为操作是在原数组上进行的，没有使用额外空间。