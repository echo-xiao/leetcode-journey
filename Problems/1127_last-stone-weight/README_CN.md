# 1127. 最后一块石头的重量

**难度**: Easy | **标签**: `Array` `Heap (Priority Queue)`

## 题目描述

<p>有一堆石头，每块石头的重量都是正整数。</p>

<p>每一回合，从中选出两块<strong> 最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x <= y</code>。那么粉碎的可能结果如下：</p>

<ul>
	<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
	<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>

<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p>

<p> </p>

<p><strong>示例：</strong></p>

<pre>
<strong>输入：</strong>[2,7,4,1,8,1]
<strong>输出：</strong>1
<strong>解释：</strong>
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= stones.length <= 30</code></li>
	<li><code>1 <= stones[i] <= 1000</code></li>
</ul>


---
## 解题思路与复盘

1. **一句话直击本质：** 使用最大堆模拟石头碰撞过程，每次取出最大的两块石头进行碰撞，直到剩下一块或没有石头。

2. **综合思路：**
   - **最大堆解法：** 使用最大堆（通过 Python 的 `heapq` 实现为最小堆，存储负数来模拟最大堆）来管理石头重量，每次取出最大的两块石头进行碰撞，若有剩余则将差值重新放入堆中，直到堆中剩下一块或没有石头。
   - **排序解法（未在提供的代码中出现）：** 另一种思路是每次排序石头数组，取出最大的两块进行碰撞，这种方法在效率上不如堆实现。

3. **全量伪代码：**

   - **最大堆解法伪代码：**
     ```
     初始化一个空的最大堆 maxHeap
     对于每个石头重量 s 在 stones 中：
         将 -s 插入 maxHeap 以模拟最大堆

     当 maxHeap 中的元素数量大于 1 时：
         取出最大元素 y = heapq.heappop(maxHeap)
         取出次大元素 x = heapq.heappop(maxHeap)
         如果 x 不等于 y：
             将 y-x 插入 maxHeap

     如果 maxHeap 为空：
         返回 0
     否则：
         返回 -maxHeap[0]
     ```

4. **复杂度：**
   - 时间复杂度：$O(n \log n)$，其中 $n$ 是石头的数量。每次插入和删除操作的时间复杂度为 $O(\log n)$，最多进行 $n-1$ 次操作。
   - 空间复杂度：$O(n)$，用于存储最大堆。