# 111. 二叉树的最小深度

**难度**: Easy | **标签**: `Tree` `Depth-First Search` `Breadth-First Search` `Binary Tree`

## 题目描述

<p>给定一个二叉树，找出其最小深度。</p>

<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>

<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" style="width: 432px; height: 302px;" />
<pre>
<strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>2
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>root = [2,null,3,null,4,null,5,null,6]
<strong>输出：</strong>5
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中节点数的范围在 <code>[0, 10<sup>5</sup>]</code> 内</li>
	<li><code>-1000 <= Node.val <= 1000</code></li>
</ul>


---
## 解题思路与复盘

1. 一句话直击本质：
   - 使用广度优先搜索（BFS）或深度优先搜索（DFS）来找到从根节点到最近叶子节点的最短路径长度。

2. 综合思路：
   - **广度优先搜索（BFS）**：使用队列进行层次遍历，找到第一个叶子节点时返回其深度，因为BFS保证了最先找到的叶子节点就是最浅的。
   - **深度优先搜索（DFS）**：使用递归来遍历每个节点，计算左右子树的最小深度，注意处理只有一个子树为空的情况。

3. 全量伪代码：
   - **BFS 版本伪代码**：
     ```
     如果根节点为空，返回 0
     初始化队列 q，加入根节点和深度 1
     当队列不为空时：
         弹出队列中的节点和其深度
         如果该节点是叶子节点，返回当前深度
         如果左子节点存在，加入队列，深度加 1
         如果右子节点存在，加入队列，深度加 1
     ```
   - **DFS 版本伪代码**：
     ```
     如果根节点为空，返回 0
     如果节点是叶子节点，返回 1
     计算左子树的最小深度
     计算右子树的最小深度
     如果左子树为空，返回右子树深度加 1
     如果右子树为空，返回左子树深度加 1
     返回左右子树深度的最小值加 1
     ```

4. 复杂度：
   - 时间复杂度：对于所有版本，时间复杂度均为 $O(n)$，其中 $n$ 是二叉树中的节点数，因为每个节点都需要访问一次。
   - 空间复杂度：对于递归版本，空间复杂度为 $O(h)$，其中 $h$ 是树的高度，因递归栈的深度；对于迭代版本（BFS），空间复杂度为 $O(w)$，其中 $w$ 是树的最大宽度。