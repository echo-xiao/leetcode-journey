# 695. 岛屿的最大面积

**难度**: Medium | **标签**: `Array` `Depth-First Search` `Breadth-First Search` `Union-Find` `Matrix`

## 题目描述

<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>

<p><strong>岛屿</strong>&nbsp;是由一些相邻的&nbsp;<code>1</code>&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上 </strong>相邻。你可以假设&nbsp;<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>

<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>

<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" style="width: 500px; height: 310px;" />
<pre>
<strong>输入：</strong>grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
<strong>输出：</strong>6
<strong>解释：</strong>答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直这四个方向上的 <code>1</code> 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>grid = [[0,0,0,0,0,0,0,0]]
<strong>输出：</strong>0
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>


---
## 解题思路与复盘

1. 一句话直击本质：通过遍历网格并使用不同的搜索策略（如并查集、BFS、DFS）来计算每个岛屿的面积，并记录最大值。

2. 综合思路：
   - **并查集**：将每个陆地单元格视为一个节点，通过合并相邻节点来形成岛屿，并在合并过程中更新最大面积。
   - **广度优先搜索（BFS）**：从每个未访问的陆地单元格开始，使用队列探索整个岛屿，并计算其面积。
   - **深度优先搜索（DFS）**（迭代）：使用栈从每个未访问的陆地单元格开始，探索整个岛屿并计算其面积。
   - **深度优先搜索（DFS）**（递归）：递归地从每个未访问的陆地单元格开始，探索整个岛屿并计算其面积。

3. 全量伪代码：
   - **并查集**：
     ```
     初始化 parent 和 size 数组
     对于每个单元格：
         如果是陆地：
             初始化其大小为 1
     对于每个单元格：
         如果是陆地：
             检查右边和下边的邻居
             如果邻居是陆地，合并两个节点
             更新最大面积
     返回最大面积
     ```
   - **广度优先搜索（BFS）**：
     ```
     初始化最大面积为 0
     对于每个单元格：
         如果是陆地：
             初始化队列并将当前单元格入队
             初始化当前岛屿面积为 1
             将当前单元格标记为已访问
             当队列不为空：
                 取出队首元素
                 检查四个方向的邻居
                 如果邻居是陆地，将其入队并标记为已访问
                 增加当前岛屿面积
             更新最大面积
     返回最大面积
     ```
   - **深度优先搜索（DFS）**（迭代）：
     ```
     初始化最大面积为 0
     对于每个单元格：
         如果是陆地：
             初始化栈并将当前单元格入栈
             初始化当前岛屿面积为 1
             将当前单元格标记为已访问
             当栈不为空：
                 取出栈顶元素
                 检查四个方向的邻居
                 如果邻居是陆地，将其入栈并标记为已访问
                 增加当前岛屿面积
             更新最大面积
     返回最大面积
     ```
   - **深度优先搜索（DFS）**（递归）：
     ```
     定义递归函数 dfs(r, c):
         如果超出边界或当前单元格不是陆地，返回 0
         将当前单元格标记为已访问
         返回 1 + 对四个方向的邻居调用 dfs 的结果之和
     初始化最大面积为 0
     对于每个单元格：
         如果是陆地：
             计算当前岛屿面积为 dfs(r, c) 的结果
             更新最大面积
     返回最大面积
     ```

4. 复杂度：
   - **时间复杂度**：所有方法的时间复杂度均为 $O(R \times C)$，其中 $R$ 是网格的行数，$C$ 是列数，因为每个单元格最多被访问一次。
   - **空间复杂度**：
     - 并查集：$O(R \times C)$，用于存储 parent 和 size 数组。
     - BFS 和 DFS（迭代）：$O(\min(R, C))$，用于存储队列或栈。
     - DFS（递归）：$O(R \times C)$，最坏情况下递归栈的深度。