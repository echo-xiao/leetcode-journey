# 1078. 删除最外层的括号

**难度**: Easy | **标签**: `String` `Stack`

## 题目描述

<p>有效括号字符串为空 <code>""</code>、<code>"(" + A + ")"</code> 或 <code>A + B</code> ，其中 <code>A</code> 和 <code>B</code> 都是有效的括号字符串，<code>+</code> 代表字符串的连接。</p>

<ul>
	<li>例如，<code>""</code>，<code>"()"</code>，<code>"(())()"</code> 和 <code>"(()(()))"</code> 都是有效的括号字符串。</li>
</ul>

<p>如果有效字符串 <code>s</code> 非空，且不存在将其拆分为 <code>s = A + B</code> 的方法，我们称其为<strong>原语（primitive）</strong>，其中 <code>A</code> 和 <code>B</code> 都是非空有效括号字符串。</p>

<p>给出一个非空有效字符串 <code>s</code>，考虑将其进行原语化分解，使得：<code>s = P_1 + P_2 + ... + P_k</code>，其中 <code>P_i</code> 是有效括号字符串原语。</p>

<p>对 <code>s</code> 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 <code>s</code> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "(()())(())"
<strong>输出：</strong>"()()()"
<strong>解释：
</strong>输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "(()())(())(()(()))"
<strong>输出：</strong>"()()()()(())"
<strong>解释：</strong>
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = "()()"
<strong>输出：</strong>""
<strong>解释：</strong>
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= s.length <= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li>
	<li><code>s</code> 是一个有效括号字符串</li>
</ul>


---
## 解题思路与复盘

1. 一句话直击本质：通过维护一个计数器或栈来追踪括号的嵌套层级，从而识别并去除最外层的括号。

2. 综合思路：
   - **栈方法**：使用栈来追踪括号的嵌套层级，遇到左括号时压入栈，遇到右括号时弹出栈，只有在栈不为空时才将括号加入结果中。
   - **计数器方法**：使用计数器来追踪括号的嵌套层级，遇到左括号时计数器加一，遇到右括号时计数器减一，只有在计数器大于一时才将括号加入结果中。

3. 全量伪代码：
   - **栈方法伪代码**：
     ```
     初始化空栈和结果列表
     对于字符串中的每个字符：
         如果字符是左括号：
             如果栈不为空，将字符加入结果列表
             将字符压入栈
         如果字符是右括号：
             如果栈的长度大于1，将字符加入结果列表
             从栈中弹出一个元素
     返回结果列表拼接成的字符串
     ```
   - **计数器方法伪代码**：
     ```
     初始化结果列表和计数器为0
     对于字符串中的每个字符：
         如果字符是左括号：
             计数器加一
             如果计数器大于1，将字符加入结果列表
         如果字符是右括号：
             如果计数器大于1，将字符加入结果列表
             计数器减一
     返回结果列表拼接成的字符串
     ```

4. 复杂度：
   - 时间复杂度：$O(n)$，其中 $n$ 是字符串的长度，因为每个字符都被访问一次。
   - 空间复杂度：$O(n)$，在最坏情况下，栈或结果列表可能需要存储所有的字符。