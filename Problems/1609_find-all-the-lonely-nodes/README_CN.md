# 1609. 寻找所有的独生节点

**难度**: Easy | **标签**: `Tree` `Depth-First Search` `Breadth-First Search` `Binary Tree`

## 题目描述

None

---
## 解题思路与复盘

1. 一句话直击本质：通过深度优先搜索遍历二叉树，检查每个节点的父节点是否只有一个子节点，从而找到所有的独生节点。

2. 综合思路：
   - 递归 DFS：所有版本都使用递归的深度优先搜索（DFS）来遍历二叉树。通过递归函数传递当前节点及其父节点的信息，判断当前节点是否为独生节点。
   - 版本 1：直接检查当前节点的左右子节点是否为空来判断独生节点。
   - 版本 2-6：通过传递父节点信息，检查父节点是否只有一个子节点来判断独生节点。

3. 全量伪代码：
   ```plaintext
   定义二叉树节点类 TreeNode:
       初始化函数 __init__(值=0, 左子节点=None, 右子节点=None):
           设置节点值
           设置左子节点
           设置右子节点

   定义解决方案类 Solution:
       定义函数 getLonelyNodes(根节点):
           初始化结果列表 res
           调用 dfs 函数传入根节点和空父节点
           返回结果列表 res

       定义递归函数 dfs(当前节点, 父节点):
           如果当前节点为空:
               返回

           如果父节点不为空且父节点只有一个子节点:
               将当前节点的值添加到结果列表 res

           递归调用 dfs 函数传入当前节点的左子节点和当前节点
           递归调用 dfs 函数传入当前节点的右子节点和当前节点
   ```

4. 复杂度：
   - 时间复杂度：$O(n)$，其中 $n$ 是二叉树中的节点数，因为每个节点都被访问一次。
   - 空间复杂度：$O(h)$，其中 $h$ 是二叉树的高度，递归调用栈的深度取决于树的高度。