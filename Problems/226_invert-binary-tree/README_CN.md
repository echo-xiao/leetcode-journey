# 226. 翻转二叉树

**难度**: Easy | **标签**: `Tree` `Depth-First Search` `Breadth-First Search` `Binary Tree`

## 题目描述

<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" style="height: 165px; width: 500px;" /></p>

<pre>
<strong>输入：</strong>root = [4,2,7,1,3,6,9]
<strong>输出：</strong>[4,7,2,9,6,3,1]
</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" style="width: 500px; height: 120px;" /></p>

<pre>
<strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>[2,3,1]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>


---
## 解题思路与复盘

1. 一句话直击本质：翻转二叉树的核心逻辑是交换每个节点的左右子节点。

2. 综合思路：
   - **递归解法**：
     - 前序遍历：在递归调用子树之前交换当前节点的左右子节点。
     - 中序遍历：在递归调用左子树后交换当前节点的左右子节点，然后递归调用新的左子树。
     - 后序遍历：在递归调用完左右子树后交换当前节点的左右子节点。
   - **迭代解法**：
     - 使用广度优先搜索（BFS）：利用队列进行层序遍历，逐层交换节点的左右子节点。

3. 全量伪代码：
   - **递归前序遍历**：
     ```
     函数 翻转二叉树(节点):
         如果 节点 为 空:
             返回 空
         交换 节点.左 和 节点.右
         翻转二叉树(节点.左)
         翻转二叉树(节点.右)
         返回 节点
     ```
   - **递归中序遍历**：
     ```
     函数 翻转二叉树(节点):
         如果 节点 为 空:
             返回 空
         翻转二叉树(节点.左)
         交换 节点.左 和 节点.右
         翻转二叉树(节点.左)  # 注意这里是新的左子树
         返回 节点
     ```
   - **递归后序遍历**：
     ```
     函数 翻转二叉树(节点):
         如果 节点 为 空:
             返回 空
         左翻转 = 翻转二叉树(节点.左)
         右翻转 = 翻转二叉树(节点.右)
         节点.左 = 右翻转
         节点.右 = 左翻转
         返回 节点
     ```
   - **迭代 BFS**：
     ```
     函数 翻转二叉树(根节点):
         如果 根节点 为 空:
             返回 空
         初始化 队列 = [根节点]
         当 队列 不为空:
             当前节点 = 队列.弹出()
             交换 当前节点.左 和 当前节点.右
             如果 当前节点.左 不为空:
                 队列.添加(当前节点.左)
             如果 当前节点.右 不为空:
                 队列.添加(当前节点.右)
         返回 根节点
     ```

4. 复杂度：
   - 时间复杂度：所有解法的时间复杂度均为 $O(n)$，其中 $n$ 是二叉树的节点数，因为每个节点都需要被访问和交换一次。
   - 空间复杂度：
     - 递归解法的空间复杂度为 $O(h)$，其中 $h$ 是二叉树的高度，主要是递归调用栈的空间。
     - 迭代解法的空间复杂度为 $O(w)$，其中 $w$ 是二叉树的最大宽度，主要是队列所占用的空间。