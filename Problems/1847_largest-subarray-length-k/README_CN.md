# 1847. 长度为 K 的最大子数组

**难度**: Easy | **标签**: `Array` `Greedy`

## 题目描述

None

---
## 解题思路与复盘

1. 一句话直击本质：通过遍历数组找到起始元素最大的子数组。

2. 综合思路：
   - 迭代法：遍历数组的前 `len(nums) - k + 1` 个元素，记录最大值及其索引，然后返回从该索引开始的长度为 `k` 的子数组。
   - 直接法：直接使用内置函数 `max()` 找到前 `len(nums) - k + 1` 个元素中的最大值，然后通过 `index()` 找到其索引，返回从该索引开始的长度为 `k` 的子数组。

3. 全量伪代码：
   - 迭代法：
     ```
     初始化 maxRes 为一个很小的值
     初始化 idx 为 0
     对于 i 从 0 到 len(nums) - k:
         如果 nums[i] > maxRes:
             更新 maxRes 为 nums[i]
             更新 idx 为 i
     返回从 idx 开始长度为 k 的子数组
     ```
   - 直接法：
     ```
     计算 maxVal 为 nums 从 0 到 len(nums) - k 的最大值
     找到 maxVal 在 nums 中的索引 idx
     返回从 idx 开始长度为 k 的子数组
     ```

4. 复杂度：
   - 时间复杂度：$O(n)$，其中 $n$ 是数组的长度，因为需要遍历数组的前 `len(nums) - k + 1` 个元素。
   - 空间复杂度：$O(1)$，因为只使用了常数个额外变量。