# 266. 回文排列

**难度**: Easy | **标签**: `Hash Table` `String` `Bit Manipulation`

## 题目描述

None

---
## 解题思路与复盘

### 一句话直击本质
判断一个字符串是否可以排列成回文的核心逻辑是：字符串中最多只能有一个字符出现奇数次。

### 综合思路
1. **计数法**：使用哈希表（如 `collections.Counter`）统计每个字符的出现次数，然后检查出现次数为奇数的字符数量是否超过一个。
2. **位运算法**：利用位运算记录字符的奇偶性，通过位掩码判断奇数次字符的数量。

### 全量伪代码

#### 计数法伪代码
```
函数 canPermutePalindrome(字符串 s):
    创建一个计数器 counter 记录字符串中每个字符的出现次数
    初始化 oddCnt 为 0
    对于 counter 中的每个字符及其计数:
        如果计数是奇数:
            oddCnt 增加 1
            如果 oddCnt 大于 1:
                返回 False
    返回 True
```

#### 位运算法伪代码
```
函数 canPermutePalindrome(字符串 s):
    初始化位掩码 bitmask 为 0
    对于字符串 s 中的每个字符 c:
        计算字符 c 的位值
        切换 bitmask 中对应位的状态
    如果 bitmask 是 0 或者 bitmask 只有一个位是 1:
        返回 True
    否则:
        返回 False
```

### 复杂度
- **时间复杂度**: $O(n)$，其中 $n$ 是字符串的长度，因为需要遍历字符串统计字符频率。
- **空间复杂度**: $O(1)$，因为字符集大小固定（假设为 ASCII 字符集），计数器的大小是常数级别的。