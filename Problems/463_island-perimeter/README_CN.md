# 463. 岛屿的周长

**难度**: Easy | **标签**: `Array` `Depth-First Search` `Breadth-First Search` `Matrix`

## 题目描述

<p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p>

<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>

<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<p><img src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/10/12/island.png" /></p>

<pre>
<strong>输入：</strong>grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
<strong>输出：</strong>16
<strong>解释：</strong>它的周长是上面图片中的 16 个黄色的边</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>grid = [[1]]
<strong>输出：</strong>4
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>grid = [[1,0]]
<strong>输出：</strong>4
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>row == grid.length</code></li>
	<li><code>col == grid[i].length</code></li>
	<li><code>1 <= row, col <= 100</code></li>
	<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>


---
## 解题思路与复盘

1. 一句话直击本质：通过遍历岛屿的每个陆地单元格，计算其边界贡献来求解岛屿的总周长。

2. 综合思路：
   - **BFS 解法**：使用广度优先搜索（BFS）从某个陆地单元格开始，遍历整个岛屿，同时计算每个单元格的周长贡献。
   - **DFS 迭代解法**：使用深度优先搜索（DFS）迭代方式，从某个陆地单元格开始，遍历整个岛屿，同时计算每个单元格的周长贡献。
   - **DFS 递归解法**：使用深度优先搜索（DFS）递归方式，从某个陆地单元格开始，递归遍历整个岛屿，计算每个单元格的周长贡献。

3. 全量伪代码：

   - **BFS 解法**：
     ```
     初始化队列，加入起始陆地单元格
     将起始单元格标记为已访问
     初始化周长为0
     当队列不为空时：
         弹出队列中的当前单元格
         增加当前单元格的初始周长贡献（4）
         对于当前单元格的每个相邻单元格：
             如果相邻单元格在网格内且不是水：
                 减少当前单元格的周长贡献（1）
             如果相邻单元格是未访问的陆地：
                 标记为已访问并加入队列
     返回计算的周长
     ```

   - **DFS 迭代解法**：
     ```
     初始化栈，加入起始陆地单元格
     将起始单元格标记为已访问
     初始化周长为0
     当栈不为空时：
         弹出栈中的当前单元格
         增加当前单元格的初始周长贡献（4）
         对于当前单元格的每个相邻单元格：
             如果相邻单元格在网格内且不是水：
                 减少当前单元格的周长贡献（1）
             如果相邻单元格是未访问的陆地：
                 标记为已访问并加入栈
     返回计算的周长
     ```

   - **DFS 递归解法**：
     ```
     定义递归函数 dfs(r, c):
         如果当前单元格超出网格边界或是水：
             返回1（表示边界贡献）
         如果当前单元格已访问：
             返回0
         将当前单元格标记为已访问
         返回相邻四个方向的递归调用结果之和
     对每个网格单元格：
         如果是未访问的陆地：
             调用 dfs 并返回结果
     ```

4. 复杂度：
   - 时间复杂度：所有解法的时间复杂度均为 $O(m \times n)$，其中 $m$ 和 $n$ 分别是网格的行数和列数，因为每个单元格最多被访问一次。
   - 空间复杂度：对于 BFS 和 DFS 迭代解法，空间复杂度为 $O(m \times n)$，因为最坏情况下队列或栈可能存储整个岛屿的所有单元格。对于 DFS 递归解法，空间复杂度为 $O(m \times n)$，因为递归栈的深度可能达到整个岛屿的大小。