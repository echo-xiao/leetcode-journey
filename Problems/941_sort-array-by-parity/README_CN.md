# 941. 按奇偶排序数组

**难度**: Easy | **标签**: `Array` `Two Pointers` `Sorting`

## 题目描述

<p>给你一个整数数组 <code>nums</code>，将 <code>nums</code> 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。</p>

<p>返回满足此条件的 <strong>任一数组</strong> 作为答案。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,1,2,4]
<strong>输出：</strong>[2,4,3,1]
<strong>解释：</strong>[4,2,3,1]、[2,4,1,3] 和 [4,2,1,3] 也会被视作正确答案。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0]
<strong>输出：</strong>[0]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 5000</code></li>
</ul>


---
## 解题思路与复盘

1. **一句话直击本质：** 使用双指针法，一前一后遍历数组，通过交换元素将偶数移到数组前面，奇数移到数组后面。

2. **综合思路：**
   - **双指针法：** 使用两个指针 `i` 和 `j`，分别从数组的头和尾开始遍历，`i` 找到第一个奇数，`j` 找到第一个偶数，然后交换这两个元素，继续移动指针直到 `i` 和 `j` 相遇。
   - **分区法：** 类似于快速排序的分区过程，将数组分为两部分，前半部分为偶数，后半部分为奇数。

3. **全量伪代码：**

   - **双指针法：**
     ```
     初始化指针 i 为 0，指针 j 为数组长度减 1
     当 i 小于 j 时重复以下步骤：
         如果 nums[i] 是奇数且 nums[j] 是偶数：
             交换 nums[i] 和 nums[j]
             i 增加 1
             j 减少 1
         否则如果 nums[i] 是偶数：
             i 增加 1
         否则如果 nums[j] 是奇数：
             j 减少 1
     返回数组 nums
     ```

4. **复杂度：**

   - **时间复杂度：** $O(n)$，因为每个元素最多被访问一次。
   - **空间复杂度：** $O(1)$，因为只使用了常数级别的额外空间。