# 401. 二进制手表

**难度**: Easy | **标签**: `Backtracking` `Bit Manipulation`

## 题目描述

<p>二进制手表顶部有 4 个 LED 代表<strong> 小时（0-11）</strong>，底部的 6 个 LED 代表<strong> 分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p>

<ul>
	<li>例如，下面的二进制手表读取 <code>"4:51"</code> 。</li>
</ul>

<p><img src="https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg" style="height: 300px; width" /></p>

<p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p>

<p>小时不会以零开头：</p>

<ul>
	<li>例如，<code>"01:00"</code> 是无效的时间，正确的写法应该是 <code>"1:00"</code> 。</li>
</ul>

<p>分钟必须由两位数组成，可能会以零开头：</p>

<ul>
	<li>例如，<code>"10:2"</code> 是无效的时间，正确的写法应该是 <code>"10:02"</code> 。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>turnedOn = 1
<strong>输出：</strong>["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>turnedOn = 9
<strong>输出：</strong>[]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 &lt;= turnedOn &lt;= 10</code></li>
</ul>


---
## 解题思路与复盘

1. **一句话直击本质：** 通过回溯或动态规划方法，枚举所有可能的灯亮组合以生成有效的时间。

2. **综合思路：**
   - **回溯法（Backtracking）：** 使用递归遍历所有可能的灯亮组合，剪枝无效组合（如小时大于11或分钟大于59），并在达到目标灯亮数量时记录结果。
   - **深度优先搜索（DFS）：** 类似于回溯，递归地探索每种灯亮组合，使用深度优先的方式进行遍历。
   - **动态规划（DP）：** 使用二维数组记录不同灯亮数量下的可能时间组合，通过状态转移方程更新组合。

3. **全量伪代码：**

   - **回溯法/DFS伪代码：**
     ```
     定义函数 readBinaryWatch(turnedOn)
         初始化结果列表
         初始化灯列表（小时和分钟）
         调用辅助函数 _backtrack(起始索引, 当前灯亮数量, 当前小时, 当前分钟)
         返回结果列表

     定义辅助函数 _backtrack(起始索引, 当前灯亮数量, 当前小时, 当前分钟)
         如果当前小时大于11或当前分钟大于59，返回
         如果当前灯亮数量等于目标灯亮数量
             将当前时间格式化并添加到结果列表
             返回
         对于从起始索引到灯列表末尾的每个灯
             如果灯是小时灯，递归调用 _backtrack(下一个索引, 灯亮数量+1, 小时+灯值, 分钟)
             如果灯是分钟灯，递归调用 _backtrack(下一个索引, 灯亮数量+1, 小时, 分钟+灯值)
     ```

   - **动态规划伪代码：**
     ```
     定义函数 readBinaryWatch(turnedOn)
         初始化灯值列表（小时和分钟）
         初始化二维DP数组，大小为(N+1) x (turnedOn+1)，每个元素为集合
         对于每个灯索引i
             将(0, 0)添加到dp[i][0]
         对于每个灯索引i从1到N
             获取当前灯的小时值和分钟值
             对于每个可能的灯亮数量j从1到turnedOn
                 获取不使用当前灯的组合
                 初始化使用当前灯的组合集合
                 对于不使用当前灯的每个组合
                     计算新小时和新分钟
                     如果新小时和新分钟有效，添加到使用当前灯的组合集合
                 将不使用和使用当前灯的组合集合合并
         初始化结果列表
         对于dp[N][turnedOn]中的每个时间组合
             如果时间有效，格式化并添加到结果列表
         返回结果列表
     ```

4. **复杂度：**
   - **时间复杂度：** $O(2^N)$，其中 $N$ 是灯的数量（10个），因为需要枚举所有可能的灯亮组合。
   - **空间复杂度：** $O(2^N)$，用于存储所有可能的时间组合。