# 1618. 删除链表 M 个节点之后的 N 个节点

**难度**: Easy | **标签**: `Linked List`

## 题目描述

None

---
## 解题思路与复盘

1. 一句话直击本质：该算法的核心逻辑是通过迭代遍历链表，保留 M 个节点后跳过 N 个节点，调整链表指针以删除不需要的节点。

2. 综合思路：
   - 迭代法：通过两个指针 `slow` 和 `fast`，`slow` 用于遍历并保留 M 个节点，`fast` 用于跳过 N 个节点，然后调整 `slow` 的 `next` 指针以删除节点。
   - 递归法：可以通过递归的方式实现相同的逻辑，递归地处理链表的每一段，保留 M 个节点后跳过 N 个节点。

3. 全量伪代码：
   - 迭代法：
     ```
     初始化虚拟节点 dummy，指向链表头部
     初始化当前节点 curr 指向 dummy
     当 curr 不为空时，重复以下步骤：
         初始化 slow 指向 curr
         遍历 M 个节点：
             如果 slow 为空，跳出循环
             slow 移动到下一个节点
         如果 slow 为空，跳出循环
         初始化 fast 指向 slow 的下一个节点
         遍历 N 个节点：
             如果 fast 为空，跳出循环
             fast 移动到下一个节点
         将 slow 的 next 指针指向 fast
         更新 curr 为 slow
     返回链表头部
     ```
   - 递归法（伪代码示例）：
     ```
     定义递归函数 deleteNodesRecursively(head, m, n)
         如果 head 为空，返回 head
         初始化 curr 指向 head
         遍历 M 个节点：
             如果 curr 为空，返回 head
             curr 移动到下一个节点
         初始化 temp 指向 curr 的下一个节点
         遍历 N 个节点：
             如果 temp 为空，跳出循环
             temp 移动到下一个节点
         将 curr 的 next 指针指向 deleteNodesRecursively(temp, m, n)
         返回 head
     ```

4. 复杂度：
   - 时间复杂度：$O(n)$，其中 $n$ 是链表的节点数，因为每个节点最多被访问一次。
   - 空间复杂度：$O(1)$，因为使用了常数级别的额外空间。对于递归实现，空间复杂度为 $O(n)$，因为递归调用栈的深度与链表长度成正比。